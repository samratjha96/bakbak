import { TranscriptionJobInfo, JobStatus } from "./TranscriptionJobInfo";

// Storage key for persistent storage
const STORAGE_KEY = "bakbak_transcription_jobs";

/**
 * Manages transcription job data and status tracking
 */
export class TranscriptionJobManager {
  private jobs: Map<string, TranscriptionJobInfo> = new Map();
  private jobsByRecordingId: Map<string, string> = new Map();

  /**
   * Creates a new TranscriptionJobManager instance
   * @param persistenceEnabled Whether to persist jobs to storage
   */
  constructor(private persistenceEnabled = true) {
    if (persistenceEnabled) {
      this.loadFromStorage();
    }
  }

  /**
   * Creates a new transcription job
   * @param recordingId The ID of the recording to transcribe
   * @param jobId The ID of the job (typically generated by the transcription service)
   * @param languageCode Optional language code for the transcription
   * @returns A promise that resolves when the job is created
   */
  async createJob(
    recordingId: string,
    jobId: string,
    languageCode?: string,
  ): Promise<void> {
    const now = new Date();

    const jobInfo: TranscriptionJobInfo = {
      jobId,
      recordingId,
      status: "PENDING",
      languageCode,
      createdAt: now,
      updatedAt: now,
    };

    this.jobs.set(jobId, jobInfo);
    this.jobsByRecordingId.set(recordingId, jobId);

    if (this.persistenceEnabled) {
      this.saveToStorage();
    }
  }

  /**
   * Updates the status of a transcription job
   * @param jobId The ID of the job to update
   * @param status The new status of the job
   * @param errorMessage Optional error message if the job failed
   * @returns A promise that resolves when the job is updated
   */
  async updateJobStatus(
    jobId: string,
    status: JobStatus,
    errorMessage?: string,
  ): Promise<void> {
    const job = this.jobs.get(jobId);

    if (!job) {
      throw new Error(`Job with ID ${jobId} not found`);
    }

    const now = new Date();
    job.status = status;
    job.updatedAt = now;

    if (errorMessage) {
      job.errorMessage = errorMessage;
    }

    if (
      status === "COMPLETED" ||
      status === "FAILED" ||
      status === "CANCELLED"
    ) {
      job.completedAt = now;
    }

    this.jobs.set(jobId, job);

    if (this.persistenceEnabled) {
      this.saveToStorage();
    }
  }

  /**
   * Gets a job by recording ID
   * @param recordingId The ID of the recording
   * @returns A promise that resolves to the job info or null if not found
   */
  async getJobByRecordingId(
    recordingId: string,
  ): Promise<TranscriptionJobInfo | null> {
    const jobId = this.jobsByRecordingId.get(recordingId);

    if (!jobId) {
      return null;
    }

    return this.jobs.get(jobId) || null;
  }

  /**
   * Gets a job by job ID
   * @param jobId The ID of the job
   * @returns A promise that resolves to the job info or null if not found
   */
  async getJobById(jobId: string): Promise<TranscriptionJobInfo | null> {
    return this.jobs.get(jobId) || null;
  }

  /**
   * Lists all jobs with the given status
   * @param status Optional status to filter by (lists all pending jobs if not specified)
   * @returns A promise that resolves to an array of job info
   */
  async listJobsByStatus(
    status: JobStatus = "PENDING",
  ): Promise<TranscriptionJobInfo[]> {
    return Array.from(this.jobs.values()).filter(
      (job) => job.status === status,
    );
  }

  /**
   * Lists all pending jobs
   * @returns A promise that resolves to an array of pending job info
   */
  async listPendingJobs(): Promise<TranscriptionJobInfo[]> {
    return this.listJobsByStatus("PENDING");
  }

  /**
   * Lists all in-progress jobs
   * @returns A promise that resolves to an array of in-progress job info
   */
  async listInProgressJobs(): Promise<TranscriptionJobInfo[]> {
    return this.listJobsByStatus("IN_PROGRESS");
  }

  /**
   * Updates job metadata
   * @param jobId The ID of the job to update
   * @param metadata The metadata to update
   * @returns A promise that resolves when the job is updated
   */
  async updateJobMetadata(
    jobId: string,
    metadata: Record<string, unknown>,
  ): Promise<void> {
    const job = this.jobs.get(jobId);

    if (!job) {
      throw new Error(`Job with ID ${jobId} not found`);
    }

    job.metadata = {
      ...(job.metadata || {}),
      ...metadata,
    };
    job.updatedAt = new Date();

    this.jobs.set(jobId, job);

    if (this.persistenceEnabled) {
      this.saveToStorage();
    }
  }

  /**
   * Clears all jobs (useful for testing)
   */
  clearAllJobs(): void {
    this.jobs.clear();
    this.jobsByRecordingId.clear();

    if (this.persistenceEnabled) {
      this.saveToStorage();
    }
  }

  /**
   * Saves jobs to storage
   * @private
   */
  private saveToStorage(): void {
    try {
      // Only persist in browser environment
      if (typeof localStorage !== "undefined") {
        const serialized = JSON.stringify({
          jobs: Array.from(this.jobs.entries()),
          jobsByRecordingId: Array.from(this.jobsByRecordingId.entries()),
        });

        localStorage.setItem(STORAGE_KEY, serialized);
      }
    } catch (error) {
      console.error("Failed to save jobs to storage:", error);
    }
  }

  /**
   * Loads jobs from storage
   * @private
   */
  private loadFromStorage(): void {
    try {
      // Only load in browser environment
      if (typeof localStorage !== "undefined") {
        const serialized = localStorage.getItem(STORAGE_KEY);

        if (serialized) {
          const data = JSON.parse(serialized);

          // Clear existing data
          this.jobs.clear();
          this.jobsByRecordingId.clear();

          // Restore jobs map, converting date strings back to Date objects
          if (data.jobs && Array.isArray(data.jobs)) {
            for (const [key, value] of data.jobs) {
              // Convert date strings back to Date objects
              if (value.createdAt) value.createdAt = new Date(value.createdAt);
              if (value.updatedAt) value.updatedAt = new Date(value.updatedAt);
              if (value.completedAt)
                value.completedAt = new Date(value.completedAt);

              this.jobs.set(key, value);
            }
          }

          // Restore jobsByRecordingId map
          if (data.jobsByRecordingId && Array.isArray(data.jobsByRecordingId)) {
            for (const [key, value] of data.jobsByRecordingId) {
              this.jobsByRecordingId.set(key, value);
            }
          }
        }
      }
    } catch (error) {
      console.error("Failed to load jobs from storage:", error);
    }
  }
}
